// --- Analytics helper ---
window.ANA = {
  start: Date.now(),
  hintCount: 0,
  send(ev, params = {}) {
    try {
      gtag("event", ev, params);
    } catch (e) {}
  },
};

window.addEventListener("DOMContentLoaded", () => {
  const a = document.querySelector('a[href*="_hint.html"]');
  if (a) {
    a.addEventListener("click", () => {
      ANA.hintCount++;
      ANA.send("open_hint", { count: ANA.hintCount });
    });
  }
});

window.ANA = Object.assign(window.ANA || {}, {
  sid: Math.random().toString(36).slice(2),
  sent: new Set(),
  baseParams() {
    return {
      elapsed_sec: Math.round((Date.now() - this.start) / 1000),
      hints: this.hintCount || 0,
      save_version: typeof SAVE_VERSION === "number" ? SAVE_VERSION : null,
      room: (window.gameState && gameState.currentRoom) || null,
      sid: this.sid,
    };
  },
  once(ev, key = "", params = {}) {
    const k = `${ev}:${key}`;
    if (this.sent.has(k)) return;
    this.sent.add(k);
    this.send(ev, { ...this.baseParams(), ...params });
  },
});

// è±å®ˆç•‘ç¹æ§­ã†ç¹ï½«ç¹§ï½¹ç¹åŒ»ãƒ»ç¹ï½³é¨¾âˆ½ï½¿ï½¡é€•ï½¨ç¹å€¥Îç¹ãƒ»
function markProgress(step, extra = {}) {
  ANA.once("progress", step, { step, ...extra });
}

document.addEventListener("DOMContentLoaded", () => {
  const modal = document.querySelector(".modal-overlay");

  const closeBtn = document.querySelector(".close-btn");

  // è›»æ™„æ‚„è¿¥ï½¶è«·ä¹ã€’é«±æ«ï½¡ï½¨é‰ï½º
  modal.style.display = "none";

  // é–‰ã˜ã‚‹"
  closeBtn?.addEventListener("click", () => {
    modal.style.display = "none";
  });

  // ç¹§ï½ªç¹ï½¼ç¹èˆŒãƒ»ç¹ï½¬ç¹§ï½¤ç¹§ï½¯ç¹ï½ªç¹ãƒ»ã‘ç¸ºï½§ç¹§ã‚‹å“©ç¸ºå€¥ï½‹
  modal.addEventListener("click", (e) => {
    if (e.target === modal) modal.style.display = "none";
  });
});

document.querySelectorAll("#modal button").forEach((btn) => {
  if (btn.textContent === "OK") {
    btn.classList.add("ok-btn");
  }
});

window._nextModal = null;
const canvas = document.getElementById("gameCanvas");
let DEV_MODE = false;
let uiLang = "jp"; // 'jp' | 'en'
const USE_LOCAL_ASSETS = location.protocol === "file:" || location.hostname === "localhost" || location.search.includes("localimg=1");
const BASE_30 = USE_LOCAL_ASSETS ? "images/30" : "https://pub-40dbb77d211c4285aa9d00400f68651b.r2.dev/images/30";
const BASE_COMMON = USE_LOCAL_ASSETS ? "images" : "https://pub-40dbb77d211c4285aa9d00400f68651b.r2.dev/images";
const I30 = (file) => `${BASE_30}/${file}`;
const ICM = (file) => `${BASE_COMMON}/${file}`;
// ç¹§ï½²ç¹ï½¼ç¹ï£°éšªï½­è³ãƒ»- é€•ï½»èœ’ä¸Šãƒ±ç¹§ï½¹ç¹§åµï¼…ç¸ºè–™ã€’é‚‚ï½¡é€…ãƒ»
let IMAGES = {
  rooms: {
    ticketArea: [I30("ticket_area.webp")],
    fujiTunnel: [I30("fuji_tunnel.webp")],

    // book1: {
    //   jp: [I30("book_1.png")],
    //   en: [I30("book_1en.png")],
    // },
    // book2: {
    //   jp: [I30("book_2.png")],
    //   en: [I30("book_2en.png")],
    // },

    // end: [I30("end.webp")],
    // endWorse: [I30("end_worse.png"), I30("end_worse2.webp")],
    // trueEnd: [I30("true_end.webp")],
  },
  items: {
    coin: ICM("bear_coin.png"),
    bear: ICM("bear.png"),
    back: ICM("common/back.png"),
    arrowRight: ICM("common/arrow_right.png"),
    arrowLeft: ICM("common/arrow_left.png"),
    arrowAbove: ICM("common/arrow_above.png"),
    redBack: ICM("common/red_back.png"),
    greenBack: ICM("common/green_back.png"),
    blueBack: ICM("common/blue_back.png"),
    blackBack: ICM("common/black_back.png"),
    lang_en: ICM("common/en2.png"),
    lang_jp: ICM("common/jp.png"),
    robo: I30("robo.webp"),
    wallet: I30("wallet.webp"),
  },

  modals: {
    // order: I30("order.png"),
    fujiNum: I30("fuji_num.webp"),
    fujiFlower: I30("modal_fuji_flower.webp"),

    // onigiriHammer: I30("modal_onigiri_hammer.webp"),
    // bearHappy: I30("modal_bear_happy.jpeg"),
  },
};

// ã‚²ãƒ¼ãƒ çŠ¶æ…‹
const SAVE_KEY = "escapeGameState30";
const SAVE_VERSION = 1;
const SAVE_KEYS = [SAVE_KEY + "_1", SAVE_KEY + "_2"];

// æ—§1ã‚¹ãƒ­ãƒƒãƒˆã‚»ãƒ¼ãƒ–ãŒã‚ã‚Œã°ã€è‡ªå‹•ã§ã‚¹ãƒ­ãƒƒãƒˆ1ã«ç§»è¡Œ
(function migrateOldSave() {
  try {
    const old = localStorage.getItem(SAVE_KEY);
    const slot1 = localStorage.getItem(SAVE_KEYS[0]);
    if (old && !slot1) {
      localStorage.setItem(SAVE_KEYS[0], old);
      // è ¢ãƒ»ï½¦âˆšâ†‘ç¹§ç‰™å•†ç¸ºãƒ»ãç¹ï½¼ç¸ºï½¯è±¸åŒ»ï¼ ç¸ºï½¦ç¹§ï¼K
      // localStorage.removeItem(SAVE_KEY);
      console.log("æ—§ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ãƒ­ãƒƒãƒˆ1ã«ç§»è¡Œã—ã¾ã—ãŸ");
    }
  } catch (e) {
    console.warn("ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ç§»è¡Œã«å¤±æ•—", e);
  }
})();

function getDefaultGameState() {
  return {
    currentRoom: "ticketArea",
    openRooms: ["ticketArea"],
    openRoomsTmp: [],
    inventory: [],
    main: {
      flags: {
        plugOn: false,
        foundWallet: false,

        talkTo: { bear: 0 },
        backgroundState: 0,
      },
    },
    endWorse: {
      flags: { backgroundState: 0 },
    },
    end: {
      flags: { backgroundState: 0 },
    },
    trueEnd: {
      flags: { backgroundState: 0 },
    },

    flags: { trueEndUnlocked: false },
    selectedItem: null,
    usingItem: null,
    endings: { true: false, normal2: false, normal: false },
  };
}

let gameState = getDefaultGameState();

// é©›ï½¨è»ä¹ãƒ§ç¹ï½¼ç¹§ï½¿
let rooms = {
  ticketArea: {
    name: "ç¹âˆšã“ç¹ãƒ»ãƒ¨è¢ï½²ç¹§é›ï£°ï½´",
    description: "",
    clickableAreas: [
      {
        x: 0,
        y: 50.8,
        width: 6.4,
        height: 6.4,
        onClick: clickWrap(
          function () {
            changeRoom("fujiTunnel");
          },
          { allowAtNight: true },
        ),
        description: "ç¹âˆšã“ç¹ãƒ»ãƒ¨è¢ï½²ç¹§é›ï£°ï½´èŸ¾ï½¦",
        zIndex: 5,
        item: { img: "arrowLeft", visible: () => true },
      },
    ],
  },
  fujiTunnel: {
    name: "è—¤æ£š",
    description: "",
    clickableAreas: [
      { x: 51.1, y: 71.1, width: 13.8, height: 12.1, onClick: clickWrap(function () {}), description: "è—¤æ£š", zIndex: 5, usable: () => true, item: { img: "robo", visible: () => true } },
      {
        x: 78.9,
        y: 87.6,
        width: 5.9,
        height: 6.4,
        onClick: clickWrap(function () {
          acquireItemOnce("foundWallet", "wallet", "è²¡å¸ƒãŒè½ã¡ã¦ã„ãŸ", IMAGES.items.wallet, "è²¡å¸ƒã‚’æ‹¾ã£ãŸ");
        }),
        description: "è²¡å¸ƒ",
        zIndex: 5,
        usable: () => !gameState.main.flags.foundWallet,
        item: { img: "wallet", visible: () => !gameState.main.flags.foundWallet },
      },
      {
        x: 0.3,
        y: 50.8,
        width: 43.4,
        height: 31.7,
        onClick: clickWrap(function () {
          showObj(null, "", IMAGES.modals.fujiNum, "è—¤æ£šã®æ•°å­—");
        }),
        description: "è—¤æ£šã®æ•°å­—",
        zIndex: 5,
        usable: () => true,
        item: { img: "IMAGE_KEY", visible: () => true },
      },
      {
        x: 50.6,
        y: 57.5,
        width: 15.6,
        height: 7.2,
        onClick: clickWrap(function () {
          showObj(null, "", IMAGES.modals.fujiFlower, "è—¤ã®èŠ±ã ");
        }),
        description: "è—¤ã®èŠ±",
        zIndex: 5,
        usable: () => true,
        item: { img: "", visible: () => true },
      },

      {
        x: 93.6,
        y: 50.6,
        width: 6.4,
        height: 6.4,
        onClick: clickWrap(
          function () {
            changeRoom("ticketArea");
          },
          { allowAtNight: true },
        ),
        description: "è—¤æ£šå³",
        zIndex: 5,
        item: { img: "arrowRight", visible: () => true },
      },
    ],
  },

  end: {
    name: "ãƒãƒ¼ãƒãƒ«ã‚¨ãƒ³ãƒ‰",
    description: "",
    clickableAreas: [
      {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        onClick: clickWrap(function () {
          showEndingReport("end");
        }),
        description: "ãƒãƒ¼ãƒãƒ«ã‚¨ãƒ³ãƒ‰",
      },
    ],
  },

  trueEnd: {
    name: "ãƒˆã‚¥ãƒ«ãƒ¼ã‚¨ãƒ³ãƒ‰",
    description: "ãƒˆã‚¥ãƒ«ãƒ¼ã‚¨ãƒ³ãƒ‰ã§ã™",
    clickableAreas: [
      {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        onClick: clickWrap(function () {
          updateMessage("");
          showEndingReport("trueEnd");
        }),
        description: "ã¨ã‚¯ãƒ«ãƒ¼ã‚¨ãƒ³ãƒ‰",
        usable: () => true,
      },
    ],
  },
};

const hintMessages = {
  main: {
    bear: [],
  },
};

function travelWithSteps(destRoom = "end", color = "#000") {
  const canvasEl = document.getElementById("gameCanvas");
  const overlay = document.getElementById("roomEffectOverlay");

  try {
    const se = document.getElementById("se-ashioto");
    if (se) {
      se.currentTime = 0;
      se.play();
    }
  } catch (e) {}

  if (overlay) {
    overlay.style.background = color;
    overlay.style.opacity = 1;
  }

  let step = 0;
  const stepTimer = setInterval(() => {
    step++;

    if (step >= 3) {
      clearInterval(stepTimer);

      if (overlay) {
        changeRoom(destRoom);
      }

      setTimeout(() => {
        if (overlay) {
          // overlay.style.background = '';
          overlay.style.opacity = 0;
        }
      }, 100);
    }
  }, 160);
}

function travelWithStepsTrueEnd() {
  const overlay = document.getElementById("roomEffectOverlay");
  let destRoom = "trueEnd";
  if (gameState.main.flags.watchOutside) {
    gameState.trueEnd.flags.backgroundState++;
  }

  try {
    const se = document.getElementById("se-ashioto");
    if (se) {
      se.currentTime = 0;
      se.play();
    }
  } catch (e) {}

  if (overlay) {
    overlay.style.background = "#fff";
    overlay.style.opacity = 1;
  }

  let step = 0;
  const stepTimer = setInterval(() => {
    step++;

    if (step >= 3) {
      clearInterval(stepTimer);

      if (overlay) {
        overlay.classList.add("warp-active");
        changeRoom(destRoom);
        overlay.style.background = "";
      }

      setTimeout(() => {
        if (overlay) {
          overlay.classList.remove("warp-active");
          overlay.style.opacity = 0;
        }
      }, 900);
    }
  }, 260);
}

function quickBlackFade(duration = 300) {
  const fade = document.getElementById("roomEffectOverlay");
  if (!fade) return;

  fade.style.background = "#000";
  fade.style.opacity = "1";

  setTimeout(() => {
    fade.style.opacity = "0";
  }, duration);
}

function initGame() {
  renderNavigation();
  changeRoom("ticketArea");
  updateMessage("æ°—ãŒä»˜ãã¨ã‚ãªãŸã¯ã€ãƒã‚±ãƒƒãƒˆå£²ã‚Šå ´ã«ç«‹ã£ã¦ã„ã¾ã—ãŸ");
  try {
    renderStatusIcons();
  } catch (e) {}
}

function findHitArea(x, y, clickableAreas, canvas) {
  // zIndexé™é †ã§
  const sorted = clickableAreas.slice().sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
  for (const area of sorted) {
    const usable = area.usable === undefined ? true : typeof area.usable === "function" ? area.usable() : area.usable;

    if (!usable) continue;
    const ax = (area.x / 100) * canvas.width;
    const ay = (area.y / 100) * canvas.height;
    const aw = (area.width / 100) * canvas.width;
    const ah = (area.height / 100) * canvas.height;
    if (x >= ax && x <= ax + aw && y >= ay && y <= ay + ah) {
      return area;
    }
  }
  return null;
}

let hoveredAreaIndex = null;
canvas.addEventListener("mousemove", function (e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;

  const room = rooms[gameState.currentRoom];
  const area = findHitArea(x, y, room.clickableAreas, canvas);
  const idx = area ? room.clickableAreas.indexOf(area) : null;
  if (hoveredAreaIndex !== idx) {
    hoveredAreaIndex = idx;
    renderCanvasRoom();
  }
});

canvas.addEventListener("mouseout", function () {
  if (hoveredAreaIndex !== null) {
    hoveredAreaIndex = null;
    renderCanvasRoom();
  }
});

canvas.addEventListener("click", function (e) {
  if (gameState.fx && gameState.fx.lockInput) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;

  const room = rooms[gameState.currentRoom];
  const area = findHitArea(x, y, room.clickableAreas, canvas);

  // if (area) {
  //     handleAreaClick(area.action, e);
  // }
  if (area) {
    if (typeof area.onClick === "function") {
      area.onClick(e);
      playSE("se-click");
    } else if (area.action) {
      handleAreaClick(area.action, e);
    }
  }
});

function changeRoom(roomId) {
  const prevRoom = gameState.currentRoom;

  gameState.currentRoom = roomId;
  const room = rooms[roomId];

  renderCanvasRoom();
  const msg = room.name && room.name.trim() !== "" ? `${room.name}ç¸ºï½§ç¸ºå¶Â€ãƒ»{room.description}` : room.description;
  if (roomId === "trueEnd") {
    updateMessageHTML(msg);
  } else {
    updateMessage(msg);
  }

  // BGM
  if (roomId === "trueEnd" || roomId === "trueEnd2") {
    changeBGM("sounds/29/Prosit!.mp3");
  } else if (roomId === "endWorse") {
    changeBGM("sounds/29/Egoist.mp3");
  } else if (roomId === "end") {
    changeBGM("sounds/29/Toy_Carnival.mp3");
  } else if (gameState.main.flags.kaniDead) {
    changeBGM("sounds/28/Ayamachi_No_Daisho-1(Slow).mp3");
  } else {
    changeBGM("sounds/30/wano_machinami.mp3");
  }

  // nav
  // if (roomId === "corridor") {
  //     addNaviItem(roomId);
  //     renderNavigation();
  // }
  if (roomId === "trueEnd" || roomId === "end" || roomId === "endWorse") {
    gameState.openRooms = [];
    // renderNavigation();
  }
  renderNavigation();
}

const END_IDS = new Set(["end", "endWorse", "trueEnd"]);

// ===== changeRoom ãƒ•ãƒƒã‚¯ï¼š=====
const _changeRoom_custom = changeRoom;
changeRoom = function (roomId) {
  _changeRoom_custom.apply(this, arguments);

  if (roomId === "end") {
    const f = gameState.main.flags || (gameState.main.flags = {});
    if (f.playHanabiOnEnd) {
      f.playHanabiOnEnd = false;
      playSE?.("se-hanabi");
    }
  }

  if (END_IDS.has(roomId)) {
    const elapsed = Math.round((Date.now() - ANA.start) / 1000);
    ANA.endTimes = ANA.endTimes || {};
    if (!ANA.endTimes[roomId]) ANA.endTimes[roomId] = elapsed;

    const isTrue = roomId === "trueEnd";
    ANA.send("ending_reached", {
      ending_id: roomId,
      is_true: isTrue,
      elapsed_sec: elapsed,
      hints: ANA.hintCount,
    });
    // setTimeout(() => showFeedbackModal(roomId), 1500);
  }
};

function renderCanvasRoom() {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const roomId = gameState.currentRoom;
  const room = rooms[roomId];
  const bgImgSrc = getRoomBackgroundImage(roomId, gameState);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // èƒŒæ™¯æç”»
  const bgImg = loadedImages[bgImgSrc];
  if (bgImg && bgImg.complete) {
    ctx.save();
    const phase = gameState.main?.flags?.timePhase ?? 0;
    const isNight = phase === 2;
    if (isNight) {
      ctx.filter = "saturate(0.3) brightness(0.6)";
    } else {
      ctx.filter = "none";
    }
    ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  // ã‚¢ã‚¤ãƒ†ãƒ æç”»ï¼ˆæœªå–å¾—ã®ã¿ï¼‰
  drawRoomItems(ctx, canvas, roomId);

  // â˜… ã“ã“ã‹ã‚‰é‡ãªã‚Šå„ªå…ˆã®hoveræ ç·šã‚’æç”»
  if (hoveredAreaIndex !== null && hoveredAreaIndex !== undefined) {
    // zIndexé™é †ã§ã‚½ãƒ¼ãƒˆ
    const sortedAreas = room.clickableAreas
      .map((area, i) => ({ ...area, __idx: i }))
      .filter((area) => (area.usable === undefined ? true : typeof area.usable === "function" ? area.usable() : area.usable))
      .sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
    // hoveredAreaIndexã¨ä¸€è‡´ã™ã‚‹ã‚¨ãƒªã‚¢ã‚’zIndexé †ã§1ã¤ã ã‘æ æç”»
    const hoverArea = sortedAreas.find((area) => area.__idx === hoveredAreaIndex);
    if (hoverArea) {
      const ax = (hoverArea.x / 100) * canvas.width;
      const ay = (hoverArea.y / 100) * canvas.height;
      const aw = (hoverArea.width / 100) * canvas.width;
      const ah = (hoverArea.height / 100) * canvas.height;
      ctx.save();
      ctx.strokeStyle = "gold";
      ctx.lineWidth = 2;
      ctx.strokeRect(ax, ay, aw, ah);
      ctx.restore();
    }
  }

  if (DEV_MODE) {
    ctx.save();
    ctx.lineWidth = 2;

    room.clickableAreas.forEach((a) => {
      ctx.strokeStyle = "rgba(255,0,0,0.8)";
      ctx.fillStyle = "rgba(255,0,0,0.35)";
      ctx.font = "14px sans-serif";
      const px = (a.x / 100) * canvas.width;
      const py = (a.y / 100) * canvas.height;
      const pw = (a.width / 100) * canvas.width;
      const ph = (a.height / 100) * canvas.height;

      // åŠé€æ˜ã®æ 
      ctx.fillRect(px, py, pw, ph);
      ctx.strokeRect(px, py, pw, ph);

      // description è¡¨ç¤º
      if (a.description) {
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(px, py - 18, ctx.measureText(a.description).width + 8, 18);

        ctx.fillStyle = "white";
        ctx.fillText(a.description, px + 4, py - 4);
      }
    });

    ctx.restore();
  }
}

function drawRoomItems(ctx, canvas, roomId) {
  const room = rooms[roomId];
  const fx = gameState.fx || {};

  room.clickableAreas.forEach((area) => {
    if (area.item && area.item.visible && area.item.visible()) {
      const key = typeof area.item.img === "function" ? area.item.img() : area.item.img;

      const img = loadedImages[IMAGES.items[key]];
      if (img && img.complete && img.naturalWidth > 0) {
        const alpha = area.alpha ? area.alpha : 1;
        const px = (area.x / 100) * canvas.width;
        const py = (area.y / 100) * canvas.height;
        const w = (area.width / 100) * canvas.width;
        const h = (area.height / 100) * canvas.height;
        ctx.save();
        ctx.globalAlpha = alpha;

        // â˜… å¤œãƒ¢ãƒ¼ãƒ‰ãªã‚‰å½©åº¦ï¼‹æ˜ã‚‹ã•ã‚’è½ã¨ã™
        const phase = gameState.main?.flags?.timePhase ?? 0;
        const isNight = phase === 2;
        if (isNight) {
          // å€¤ã¯å¥½ã¿ã§èª¿æ•´
          ctx.filter = "saturate(0.4) brightness(0.8)";
        } else {
          ctx.filter = "none";
        }

        // â˜… drawRoomItems å†…ï¼šctx.drawImage(img, px, py, w, h); ã‚’ç½®ãæ›ãˆ
        const rotDeg = area.item && typeof area.item.rotateDeg === "function" ? area.item.rotateDeg() : area.item ? area.item.rotateDeg : 0;

        if (rotDeg) {
          const rad = (rotDeg * Math.PI) / 180;
          const cx = px + w / 2;
          const cy = py + h / 2;

          ctx.translate(cx, cy);
          ctx.rotate(rad);
          ctx.drawImage(img, -w / 2, -h / 2, w, h);
        } else {
          ctx.drawImage(img, px, py, w, h);
        }

        // ctx.drawImage(img, px, py, w, h);
        ctx.restore();
      }
    }
  });
}

function getRoomBackgroundImage(roomId, gameState) {
  let imgList = IMAGES.rooms[roomId]; // ç¬˜ãƒ»const ç«Šãƒ»let

  // â˜… book1ã€œ3ã¿ãŸã„ã« {jp:[], en:[]} å½¢å¼ãªã‚‰è¨€èªã§é¸ã¶
  if (imgList && !Array.isArray(imgList) && (imgList.jp || imgList.en)) {
    imgList = imgList[uiLang] || imgList.jp || imgList.en;
  }

  // å˜ä¸€ç”»åƒãªã‚‰ãã®ã¾ã¾
  if (!Array.isArray(imgList)) {
    return imgList;
  }

  const state = gameState[roomId]?.flags?.backgroundState ?? 0;
  return imgList[state] || imgList[0];
}

// ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ãƒ¬ã‚¤ãƒ¤ã‚’ç”¨æ„
(function ensureFlashLayer() {
  if (!document.getElementById("fxFlash")) {
    const d = document.createElement("div");
    d.id = "fxFlash";
    document.body.appendChild(d);
  }
})();

// ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆtype: 'white' | 'red'ï¼‰
function screenFlash(type = "white", durMs = 180) {
  const f = document.getElementById("fxFlash");
  if (!f) return;
  f.style.animation = "none";
  // å¼·åˆ¶reflowã§ã‚¢ãƒ‹ãƒ¡å†é©ç”¨
  // eslint-disable-next-line no-unused-expressions
  f.offsetHeight;
  const key = type === "red" ? "flashRed" : "flashWhite";
  f.style.animation = `${key} ${durMs}ms ease`;
  // ãƒšãƒ¼ã‚¸å…¨ä½“ã‚’æ¥µå°ã‚·ã‚§ã‚¤ã‚¯
  document.documentElement.classList.add("fx-shake");
  setTimeout(() => document.documentElement.classList.remove("fx-shake"), 120);
}

// ç”»é¢æºã‚Œ
function screenShake(el = document.documentElement, ms = 120, cls = "fx-shake") {
  if (!el) return;
  // é€£æ‰“ã§ã‚‚å¿…ãšç™ºç«ã•ã›ã‚‹
  el.classList.remove(cls);
  void el.offsetHeight; // reflow
  el.classList.add(cls);
  setTimeout(() => el.classList.remove(cls), ms);
}

function toggleNight() {
  quickBlackFade();
  setTimeout(() => {
    renderCanvasRoom();
  }, 300);
}

function acquireItemOnce(flagKey, itemId, title, imgSrc, msg) {
  const f = gameState.main.flags;
  if (f[flagKey]) {
    if (itemId == "glass") {
      updateMessage("");
    } else {
      updateMessage("ã‚‚ã†ä½•ã‚‚ãªã„");
    }

    return;
  }
  f[flagKey] = true;
  addItem(itemId);
  renderCanvasRoom();

  showModal(title, `<img src="${imgSrc}" style="width:400px;max-width:100%;display:block;margin:0 auto 20px;">`, [{ text: "é–‰ã˜ã‚‹", action: "close" }]);
  updateMessage(msg);
}

function clickWrap(fn, { allowAtNight = false } = {}) {
  return function (...args) {
    if (gameState.main.flags.isNight && !allowAtNight) {
      updateMessage("æš—ãã¦ã‚ˆãè¦‹ãˆãªã„");
      return;
    }
    fn.apply(this, args);

    gameState.selectedItem = null;
    gameState.selectedItemSlot = null;
    updateInventoryDisplay();
  };
}

// ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒ¬ãƒãƒ¼ãƒˆ
function showEndingReport(endingId = "end") {
  const elapsedSec = Math.round((Date.now() - (ANA.start || Date.now())) / 1000);
  const m = Math.floor(elapsedSec / 60);
  const s = elapsedSec % 60;
  const timeStr = `${m}åˆ†${s.toString().padStart(2, "0")}ç§’`;

  // ä»Šä½œç”¨ã‚¨ãƒ³ãƒ‰æƒ…å ±
  const ENDING_INFO = {
    trueEnd: {
      title: "ğŸ™ TRUE END",
      label: "TRUE END",
      desc: "å€‹æ€§çš„ãªèŠ±ç«",
    },
    endWorse: {
      title: "ğŸƒâ€â™€ï¸â€â¡ï¸ END",
      label: "END",
      desc: "æš—ã„æ£®ã®ä¸­ã¸",
    },
    end: {
      title: "ğŸ† NORMAL END ",
      label: "NORMAL END ",
      desc: "ç„¡äº‹ä¾é ¼ã‚’ã“ãªã—ã¦è„±å‡ºã§ãã¾ã—ãŸï¼",
    },
  };

  const info = ENDING_INFO[endingId] || ENDING_INFO.end;

  // ã‚¨ãƒ³ãƒ‰åˆ¥ã²ã¨ã“ã¨
  let secretText = "";
  switch (endingId) {
    case "trueEnd":
      secretText = "ğŸ™ ãŠã«ãã‚Šãƒ‡ã‚¶ã‚¤ãƒ³";
      break;

    case "end":
      secretText = "â¤ ãƒãƒ¼ãƒˆã®èŠ±ç«ãŒä¸ŠãŒã‚Šã¾ã—ãŸ";
      break;

    default:
      secretText = "";
  }

  // GA
  ANA.once("ending", endingId, {
    ending: endingId,
    time_sec: elapsedSec,
  });

  const html = `
        <div style="max-width:520px; text-align:center;">
            <h2 style="margin-top:0;">${info.title}</h2>
            <p style="margin:6px 0 12px 0; font-weight:bold;">${info.desc}</p>
            <p style="margin:4px 0;">ãƒ—ãƒ¬ã‚¤æ™‚é–“ï¼š<b>${timeStr}</b></p>
            <p style="margin:4px 0;">ãƒ’ãƒ³ãƒˆåˆ©ç”¨ï¼š<b>${ANA.hintCount || 0} å›</b></p>
            ${secretText ? `<p style="margin:12px 0; font-size:.9em; opacity:.85;">${secretText}</p>` : ""}
            
            
        </div>
    `;

  showModal("ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°", html, [
    {
      text: "æœ€åˆã‹ã‚‰",
      action: "restart",
    },
    {
      text: "è©•ä¾¡ã¯ã“ã¡ã‚‰",
      action: () => openFeedbackForm(endingId),
    },
    {
      text: "é–‰ã˜ã‚‹",
      action: () => {
        closeModal();
      },
    },
  ]);
}

// ã‚¯ãƒªã‚¢ãƒ­ã‚°ç”Ÿæˆ
function copyClearLog(label, timeStr) {
  const text = `ã€å·¥æˆ¿ã‹ã‚‰ã®è„±å‡ºã€${label} ã‚¯ãƒªã‚¢\n` + `ãƒ—ãƒ¬ã‚¤æ™‚é–“ï¼š${timeStr}\n` + `ãƒ’ãƒ³ãƒˆåˆ©ç”¨ï¼š${ANA.hintCount || 0}å›\n` + `#è„±å‡ºã‚²ãƒ¼ãƒ  #ä¿è‚²å®¤ã‹ã‚‰ã®è„±å‡º`;
  navigator.clipboard
    .writeText(text)
    .then(() => {
      alert("ã‚¯ãƒªã‚¢ãƒ­ã‚°ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼");
    })
    .catch(() => {
      alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸâ€¦");
    });
}

// ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆ
function openFeedbackForm(endingId) {
  const FEEDBACK_URL = "https://docs.google.com/forms/d/e/1FAIpQLScXMaEIknd9ABM5oVrduJMLbszvVdTCc87aHQD8sZl07zmScg/viewform";

  const endingLabel =
    {
      trueEnd: "ãƒˆã‚¥ãƒ«ãƒ¼ã‚¨ãƒ³ãƒ‰",
      end: "ãƒãƒ¼ãƒãƒ«ã‚¨ãƒ³ãƒ‰",
      endWorse: "ã‚¨ãƒ³ãƒ‰",
    }[endingId] || "ã‚¨ãƒ³ãƒ‰";

  const params = new URLSearchParams({
    "entry.666725843": endingLabel,
  });

  window.open(`${FEEDBACK_URL}?${params.toString()}`, "_blank");
}

function talkToHintCharacter(roomId, charId) {
  let flags = gameState[roomId].flags;

  if (!flags.talkTo) flags.talkTo = {};
  if (!flags.talkTo[charId]) flags.talkTo[charId] = 0;

  flags.talkTo[charId]++;

  const messages = hintMessages[roomId][charId];

  const idx = (flags.talkTo[charId] - 1) % messages.length;
  console.log(flags.talkTo[charId]);

  updateMessage(messages[idx]);
}

// â–¼ æ‰‹å¸³ãƒ¢ãƒ¼ãƒ€ãƒ« æ“ä½œç”¨

function openNotebook() {
  const m = document.getElementById("notebookModal");
  if (!m) return;
  m.style.display = "flex";
  switchNotebookTab("notes");
  renderNotebookTasks();

  if (gameState.main?.flags?.notebookDeckHintAdded) {
    addDeckDoorHintNote();
  }
}

function switchNotebookTab(tabId) {
  const tabs = document.querySelectorAll(".notebook-tab");
  const contents = document.querySelectorAll(".notebook-tab-content");

  tabs.forEach((btn) => {
    const t = btn.getAttribute("data-tab");
    btn.classList.toggle("active", t === tabId);
  });

  contents.forEach((c) => c.classList.remove("active"));

  const active = document.getElementById("notebook-tab-" + tabId);
  if (active) active.classList.add("active");

  if (tabId === "notes") renderNotebookTasks();
}

function closeNotebook() {
  const m = document.getElementById("notebookModal");
  if (!m) return;
  m.style.display = "none";
}

function renderNotebookTasks() {
  const notesBody = document.getElementById("notebook-notes-body");
  if (!notesBody) return;

  const flags = gameState && gameState.main && gameState.main.flags ? gameState.main.flags : {};

  // æ—¢å­˜ã®ã€Œã‚¿ã‚¹ã‚¯æ ã€ã ã‘å·®ã—æ›¿ãˆã‚‹ï¼ˆä»–ã®è¿½è¨˜ãƒ¡ãƒ¢ãŒå°†æ¥å¢—ãˆã¦ã‚‚æ¶ˆã•ãªã„ï¼‰
  const old = document.getElementById("notebook-tasks");
  if (old) old.remove();

  const tasks = [];

  const allSolved = true;
  if (allSolved) {
    tasks.push({ text: "test", done: false });
  }

  // ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ã‚‚é€²æ—ç”¨ã«å¯„ã›ã‚‹ï¼ˆã‚¿ã‚¹ã‚¯ãªã—ãªã‚‰å…ƒã®ãƒ‹ãƒ¥ã‚¢ãƒ³ã‚¹ã«æˆ»ã™ï¼‰
  const cap = document.querySelector("#notebook-tab-notes .notebook-cap");
  if (cap) {
    cap.textContent = tasks.length > 0 ? "é€²æ—ãƒ¡ãƒ¢ãŒæ›¸ãè¶³ã•ã‚Œã¦ã„ã‚‹ã€‚" : "ç©ºç™½ã®ãƒšãƒ¼ã‚¸ã€‚";
  }

  const wrap = document.createElement("div");
  wrap.id = "notebook-tasks";
  wrap.className = "notebook-note";

  if (tasks.length === 0) {
    wrap.innerHTML = `<p style="margin:0;">ã¾ã ã‚¿ã‚¹ã‚¯ã¯ãªã„ã€‚</p>`;
    notesBody.prepend(wrap);
    return;
  }

  const rows = tasks
    .map((t) => {
      const mark = t.done ? "âœ…" : "â¬œ";
      const style = t.done ? "text-decoration:line-through;opacity:0.75;" : "";
      return `
      <li style="display:flex;gap:8px;align-items:flex-start;">
        <span style="width:1.2em;display:inline-block;">${mark}</span>
        <span style="${style}">${t.text}</span>
      </li>
    `;
    })
    .join("");

  wrap.innerHTML = `
    <div style="font-weight:700;margin:0 0 8px 0;">é€²æ—</div>
    <ul style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px;">
      ${rows}
    </ul>
  `;

  notesBody.prepend(wrap);
}

// ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ãŸã„å ´åˆï¼ˆä»»æ„ï¼‰
document.addEventListener("click", (e) => {
  const modal = document.getElementById("notebookModal");
  if (!modal) return;
  if (modal.style.display === "flex" && e.target === modal) {
    closeNotebook();
  }
});

// mainDoorãƒ»å£¼ï½¼è¼”â€³èœƒï½ºç¸ºå¶ºï½¸é ‘ï½®ï½µãƒ»åŸŸç„šèŸ„åŠ±ÎŸç¹ãƒ»ã‘ 4è­¯ãƒ»ï½¼ãƒ»
function showDrawerTopPuzzle() {
  const f = gameState.main.flags || (gameState.main.flags = {});

  if (f.unlockDrawerTop) {
    updateMessage("");
    return;
  }

  const content = `
    <div style="margin-top:10px; display:flex; flex-direction:column; align-items:center; gap:12px;">
      <div style="display:flex; gap:10px; justify-content:center; align-items:center;">
        <button class="nav-btn" id="drawerTopSq0"
          style="width:64px; height:64px; padding:0; display:flex; align-items:center; justify-content:center; font-size:32px; font-weight:900; border-radius:10px; background:#fff; color:#111;">0</button>
        <button class="nav-btn" id="drawerTopSq1"
          style="width:64px; height:64px; padding:0; display:flex; align-items:center; justify-content:center; font-size:32px; font-weight:900; border-radius:10px; background:#e8e8e8; color:#999; cursor:not-allowed;">0</button>
        <button class="nav-btn" id="drawerTopSq2"
          style="width:64px; height:64px; padding:0; display:flex; align-items:center; justify-content:center; font-size:32px; font-weight:900; border-radius:10px; background:#fff; color:#111;">0</button>
        <button class="nav-btn" id="drawerTopSq3"
          style="width:64px; height:64px; padding:0; display:flex; align-items:center; justify-content:center; font-size:32px; font-weight:900; border-radius:10px; background:#fff; color:#111;">0</button>
      </div>

      <div>
        <button id="drawerTopOk" class="ok-btn">OK</button>
      </div>

      <div id="drawerTopHint" style="margin-top:2px; font-size:0.95em; min-height:1.2em;"></div>
    </div>
  `;

  showModal("å¼•ãå‡ºã—ã®ãƒ­ãƒƒã‚¯", content, [{ text: "é–‰ã˜ã‚‹", action: "close" }]);

  setTimeout(() => {
    const sq = [document.getElementById("drawerTopSq0"), document.getElementById("drawerTopSq1"), document.getElementById("drawerTopSq2"), document.getElementById("drawerTopSq3")];
    const okBtn = document.getElementById("drawerTopOk");
    const hint = document.getElementById("drawerTopHint");
    if (!sq[0] || !sq[1] || !sq[2] || !sq[3] || !okBtn) return;

    const num = [0, 0, 0, 0];

    const paint = (i) => {
      sq[i].textContent = String(num[i]);
    };

    const cycle = (i) => {
      num[i] = (num[i] + 1) % 10;
      paint(i);
      try {
        playSE?.("se-gacha");
      } catch (e) {}
    };

    paint(0);
    paint(1);
    paint(2);
    paint(3);

    sq.forEach((btn, i) => {
      if (i !== 1) {
        btn.addEventListener("click", () => cycle(i));
      }
    });

    const judge = () => {
      const ok = num[0] === 1 && num[1] === 0 && num[2] === 3 && num[3] === 2;
      if (ok) {
        f.unlockDrawerTop = true;
        playSE?.("se-clear");
        closeModal();
        updateMessage("å¼•ãå‡ºã—ã®ãƒ­ãƒƒã‚¯ãŒé–‹ã„ãŸ");
        renderCanvasRoom?.();
        markProgress?.("unlock_drawer_top");
      } else {
        playSE?.("se-error");
        if (hint) hint.textContent = "ã¡ãŒã†ã¿ãŸã„ã ã€‚";
        screenShake?.(document.getElementById("modalContent"), 120, "fx-shake");
      }
    };

    okBtn.addEventListener("click", judge);

    // Enter=OK, 1/2/3/4=å¯¾å¿œæ ã‚’é€²ã‚ã‚‹
    const onKey = (e) => {
      if (e.key === "Enter") judge();
      if (e.key === "1") cycle(0);
      if (e.key === "2") return; // å·¦ã‹ã‚‰2ç•ªç›®ã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚‚ç„¡åŠ¹
      if (e.key === "3") cycle(2);
      if (e.key === "4") cycle(3);
    };
    document.addEventListener("keydown", onKey);

    // closeModalãƒ•ãƒƒã‚¯ã§è§£é™¤
    const _origCloseModal = window.closeModal;
    if (typeof _origCloseModal === "function") {
      window.closeModal = function () {
        try {
          document.removeEventListener("keydown", onKey);
        } catch (e) {}
        window.closeModal = _origCloseModal;
        return _origCloseModal.apply(this, arguments);
      };
    }

    sq[0].focus();
  }, 0);
}

function handleDoor() {
  const trueEndFlg = gameState.flags.trueEndUnlocked;
  const goEnding = () => {
    if (trueEndFlg) {
      gameState.endings.true = true;
      travelWithStepsTrueEnd();
    } else {
      travelWithSteps("end");
    }
  };

  goEnding();
}

function showObj(flagKey, title, imgSrc, msg, altImgSrc, msgEn) {
  const f = gameState.main.flags;
  const wasFlagOn = flagKey ? !!f[flagKey] : false;
  if (flagKey) f[flagKey] = true;
  if (flagKey === "unlockMachine" && !wasFlagOn) {
    showToast("éª­ï½¬è¬ŒèˆŒãƒ»ç¹§ï½·ç¹ï½³ç¸ºï½®è´ï½¿ç¸ºãƒ»å©¿ç¹§å‘ˆÂ€æ˜´ï¼èœƒï½ºç¸ºåŠ±â—†");
  }

  const imgId = "objImg_" + Date.now();

  const hasEn = !!altImgSrc;
  let isEn = uiLang === "en" && hasEn;

  const content = `<img id="${imgId}" src="${isEn ? altImgSrc : imgSrc}"
      style="width:400px;max-width:100%;display:block;margin:0 auto 20px;">`;

  const buttons = [];

  if (hasEn) {
    buttons.push({
      text: "EN/JP",
      action: () => {
        const el = document.getElementById(imgId);
        if (!el) return;

        uiLang = uiLang === "en" ? "jp" : "en";
        isEn = uiLang === "en";

        el.src = isEn ? altImgSrc : imgSrc;
      },
    });
  }

  buttons.push({ text: "é–‰ã˜ã‚‹", action: "close" });

  showModal(title, content, buttons);
  updateMessage(isEn ? msgEn || msg : msg);
}

function escapeHtml(str) {
  if (typeof str !== "string") return str;

  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function renderStatusIcons() {
  const area = document.getElementById("statusIconArea");
  if (!area) return;

  area.innerHTML = "";
}

function addItem(itemId) {
  playSE("se-item");
  if (gameState.inventory.length < 14) {
    gameState.inventory.push(itemId);
    updateInventoryDisplay();
  } else {
    updateMessage("ã‚¢ã‚¤ãƒ†ãƒ æ¬„ãŒã„ã£ã±ã„ã ã€‚ã©ã“ã‹ã§æ¸›ã‚‰ã—ã¦ã“ã‚ˆã†");
  }
}

function removeItem(itemId) {
  const index = gameState.inventory.indexOf(itemId);
  if (index !== -1) {
    gameState.inventory.splice(index, 1);
    gameState.selectedItem = null;
    gameState.selectedItemSlot = null;
    updateInventoryDisplay();
  }
}

function hasItem(itemId) {
  return gameState.inventory.includes(itemId);
}

function useItem(slotIndex) {
  const clickedItem = gameState.inventory[slotIndex];
  if (!clickedItem) return;

  // -------------------------
  // 1) ã€Œä½¿ç”¨å¯¾è±¡ã‚’é¸ã‚“ã§ãã ã•ã„ã€ä¸­ãªã‚‰ã€ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’å¯¾è±¡ã¨ã—ã¦åˆ¤å®š
  //    ãƒ»åˆ¥ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ãƒ©ã‚°è§£é™¤ï¼ˆæˆåŠŸ/å¤±æ•—ã©ã£ã¡ã§ã‚‚ï¼‰
  //    ãƒ»å¤±æ•—æ™‚ã¯ç„¡éŸ³ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚å‡ºã•ãªã„ï¼‰
  // -------------------------
  if (gameState.usingItem) {
    // åŒã˜ã‚¹ãƒ­ãƒƒãƒˆã‚’æŠ¼ã—ãŸã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯å‡ºã—ã¦ã‚‚å‡ºã•ãªãã¦ã‚‚OKï¼‰
    if (gameState.usingItem.slotIndex === slotIndex) {
      clearUsingItem(true);
      return;
    }

    const success = tryPutSaltOnYakisoba(clickedItem);

    // æˆåŠŸã§ã‚‚å¤±æ•—ã§ã‚‚è§£é™¤ï¼ˆä»•æ§˜ã©ãŠã‚Šï¼‰
    clearUsingItem(true);

    if (success) {
      updateMessage("ç„¼ããã°ã«å¡©ã‚’æŒ¯ã£ãŸã€‚");
      gameState.main.flags.useSaltToYakisoba = true;
      updateInventoryDisplay();
    }
    return;
  }

  // -------------------------
  // 2) å¡©ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ã€Œä½¿ç”¨å¯¾è±¡é¸æŠãƒ¢ãƒ¼ãƒ‰ã€ã¸
  // -------------------------
  if (clickedItem === "salt") {
    gameState.usingItem = { itemId: clickedItem, slotIndex };
    gameState.selectedItem = clickedItem;
    gameState.selectedItemSlot = slotIndex;
    updateMessage("è´ï½¿é€•ï½¨èŸ‡ï½¾é›ï½¡ç¹§å¸âˆˆç¹§è–™ã€’ç¸ºä¸Šâ–¡ç¸ºè¼”ï¼");
    updateInventoryDisplay();
    return;
  }

  // -------------------------
  // 3) ãã‚Œä»¥å¤–ã¯ä»Šã¾ã§é€šã‚Šã®æŒ™å‹•ï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
  // -------------------------

  // â˜…ã™ã§ã«é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’å†ã‚¯ãƒªãƒƒã‚¯ â†’ è§£é™¤
  if (gameState.selectedItem && gameState.selectedItemSlot !== slotIndex) {
    const a = gameState.selectedItem;
    const b = clickedItem;
  }

  if (gameState.selectedItemSlot === slotIndex) {
    gameState.selectedItem = null;
    gameState.selectedItemSlot = null;
    updateMessage("ã‚¢ã‚¤ãƒ†ãƒ é¸æŠã‚’è§£é™¤ã—ã¾ã—ãŸã€‚");
    updateInventoryDisplay();
    return;
  }

  // â˜…é€šå¸¸ã®é¸æŠ
  gameState.selectedItem = clickedItem;
  gameState.selectedItemSlot = slotIndex;
  updateMessage("ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠã—ãŸã€‚");
  updateInventoryDisplay();
}

function clearUsingItem(silent = true) {
  gameState.usingItem = null;
  gameState.selectedItem = null;
  gameState.selectedItemSlot = null;
  updateInventoryDisplay();
  if (!silent) updateMessage("ã‚¤ãƒ†ãƒ é¸æŠã‚’è§£é™¤ã—ã¾ã—ãŸã€‚");
}

function tryPutSaltOnYakisoba(targetItemId) {
  if (targetItemId != "yakisoba") {
    return false;
  }
  gameState.main.flags.saltToYakisobaCnt++;
  showModal("ç„¼ããã°ã«å¡©ã‚’æŒ¯ã£ãŸ", `<img src="${IMAGES.modals.yakisobaSalt}" style="width:400px;max-width:100%;display:block;margin:0 auto 20px;">`, [
    {
      text: "é–‰ã˜ã‚‹",
      action: () => {
        closeModal();
      },
    },
  ]);
  return true;
}

function getItemName(itemId) {
  const names = {
    coin: "ã‚¯ãƒã‚³ã‚¤ãƒ³",
    bear: "ã‚¯ãƒå¦–ç²¾",
  };
  return names[itemId] || itemId;
}

function renderNavigation() {
  const navDiv = document.querySelector(".navigation");
  navDiv.innerHTML = "";

  const isMobile = window.matchMedia("(max-width: 600px)").matches;

  if (isMobile) {
    const btn = document.createElement("button");
    btn.className = "nav-btn";
    btn.textContent = "ãƒŠãƒ“";
    btn.onclick = () => openNavModal();
    navDiv.appendChild(btn);
    return;
  }

  // PCã¯å¾“æ¥é€šã‚Šï¼ˆãƒ«ãƒ¼ãƒ ãƒœã‚¿ãƒ³ä¸¦ã¹ã‚‹ï¼‰
  gameState.openRooms.forEach((roomId) => {
    const b = document.createElement("button");
    b.className = "nav-btn";
    b.textContent = rooms[roomId].name;
    b.onclick = () => changeRoom(roomId);
    navDiv.appendChild(b);
  });
}

function openNavModal() {
  const cur = gameState.currentRoom;
  const listHtml = `
    <div style="display:flex;flex-direction:column;gap:10px;max-height:60vh;overflow:auto;">
      ${gameState.openRooms
        .map((roomId) => {
          const isHere = roomId === cur;
          return `
          <button class="nav-btn" style="width:100%; opacity:${isHere ? 0.5 : 1};"
            ${isHere ? "disabled" : ""}
            onclick="(function(){ closeModal(); changeRoom('${roomId}'); })()">
            ${rooms[roomId].name}${isHere ? "ï¼ˆã“ã“ï¼‰" : ""}
          </button>
        `;
        })
        .join("")}
    </div>
  `;
  showModal("ç§»å‹•å…ˆ", listHtml, [{ text: "é–‰ã˜ã‚‹", action: "close" }]);
}

function addNaviItem(room) {
  if (!gameState.openRooms.includes(room)) {
    gameState.openRooms.push(room);
    return true;
  }
  return false;
}

// ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªè¡¨ç¤ºæ›´æ–°
function updateInventoryDisplay() {
  const slots = document.querySelectorAll(".inventory-slot");
  slots.forEach((slot, index) => {
    slot.innerHTML = "";
    if (gameState.inventory[index]) {
      const img = document.createElement("img");
      img.src = IMAGES.items[gameState.inventory[index]];
      img.onerror = function () {
        // ç”»åƒãŒèª­ã¿è¾¼ã‚ãªã„å ´åˆã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’è¡¨ç¤º
        this.style.display = "none";
        const placeholder = document.createElement("div");
        placeholder.className = "image-placeholder";
        placeholder.textContent = getItemName(gameState.inventory[index]);
        placeholder.style.width = "60px";
        placeholder.style.height = "60px";
        slot.appendChild(placeholder);
      };
      slot.appendChild(img);
      const magBtn = document.createElement("div");
      magBtn.className = "magnifier-btn";
      magBtn.title = "æ‹¡å¤§è¡¨ç¤º";
      magBtn.innerHTML = '<img src="https://pub-40dbb77d211c4285aa9d00400f68651b.r2.dev/images/magnifier.png" alt="è«¡ï½¡èŸï½§">';
      magBtn.onclick = (e) => {
        e.stopPropagation();

        const itemId = gameState.inventory[index];

        // ç¹ãƒ»ãƒµç¹§ï½©ç¸ºï½®è³ï½­éœ„ï½«
        let content = `<img src="${img.src}" style="max-width:380px;max-height:380px;width:auto;height:auto;object-fit:contain;display:block;margin:0 auto 16px;">`;
        let buttons = [{ text: "é–‰ã˜ã‚‹", action: "close" }];

        if (itemId === "driver") {
          buttons = [
            {
              text: "èª¿ã¹ã‚‹",
              action: () => {
                window._nextModal = {
                  title: "è¬–âˆšâ– è¬‡ä¹ï½’ç¹§åŒ»ï¿¥éš•ä¹â—†",
                  content: `<img src="${IMAGES.modals.driverBottom}" style="max-width:380px;max-height:380px;width:auto;height:auto;object-fit:contain;display:block;margin:0 auto 16px;">`,
                  buttons: [{ text: "é–‰ã˜ã‚‹", action: "close" }],
                };
                closeModal();
                updateMessage("ç¹å³¨Î›ç¹§ï½¤ç¹èˆŒãƒ»ç¸ºï½®è¬–âˆšâ– è¬‡ä¹ï½’ç¹§åŒ»ï¿¥éš•ä¹â—†");
              },
            },
            { text: "é–‰ã˜ã‚‹", action: "close" },
          ];
        }

        showModal(getItemName(itemId), content, buttons);
      };
      slot.appendChild(magBtn);
    }
    // â˜…é¸æŠä¸­ãªã‚‰selectedã‚¯ãƒ©ã‚¹è¿½åŠ 
    if (gameState.selectedItemSlot === index) {
      slot.classList.add("selected");
    } else {
      slot.classList.remove("selected");
    }
  });
}

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ›´æ–°
function updateMessage(message) {
  //document.getElementById('messageArea').innerHTML = message;
  document.getElementById("msgText").textContent = message;
  try {
    renderStatusIcons();
  } catch (e) {}
}

function updateMessageHTML(html) {
  const el = document.getElementById("msgText");
  el.innerHTML = html;
  try {
    renderStatusIcons();
  } catch (e) {}
  el.querySelectorAll("a").forEach((a) => {
    a.target = "_blank";
    a.rel = "noopener";
    a.style.color = "#d4af37";
    a.style.textDecoration = "underline";
  });
}

// ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
function showModal(title, content, buttons, onSequenceSuccess, options) {
  options = options || {};
  let modalHtml = `<h3>${title}</h3><div>${content}</div>`;
  if (buttons && buttons.length > 0) {
    const columnStyle = options.columnButtons ? "display:flex; flex-direction:column; gap:12px; align-items:stretch;" : "text-align:center; display:flex; gap:10px; justify-content:center;";

    modalHtml += `<div id="modalButtons" style="${columnStyle}"></div>`;
    modalHtml += `<div id="modalClose" style="margin-top:25px;text-align:center;"></div>`;
  }
  document.getElementById("modalContent").innerHTML = modalHtml;
  document.getElementById("modal").style.display = "flex";

  if (!buttons || buttons.length === 0) return;

  let pressed = [];
  let heartCnt = 0;
  let checkCnt = 0;
  let houseCnt = 0;

  // ç”»åƒ/é€šå¸¸ãƒœã‚¿ãƒ³ã¨closeãƒœã‚¿ãƒ³ã§åˆ†ã‘ã‚‹
  const modalButtons = document.getElementById("modalButtons");
  const modalClose = document.getElementById("modalClose");

  buttons.forEach((button, idx) => {
    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã¯ä¸‹ã¸
    if (button.action === "close") {
      const btn = document.createElement("button");
      btn.textContent = button.text || "é–‰ã˜ã‚‹";
      btn.className = "modal-close-btn";
      btn.onclick = function () {
        closeModal();
        if (typeof onSequenceSuccess === "function") {
          onSequenceSuccess();
        }
      };
      modalClose.appendChild(btn);
    } else {
      const btn = document.createElement("button");
      btn.style.margin = "0 10px 10px 0";
      if (button.img) {
        btn.innerHTML = `<img src="${button.img}" alt="${button.text || ""}" style="width:80px;height:80px;vertical-align:middle;">`;
      } else {
        btn.textContent = button.text;
        btn.className = "text-btn";
      }
      btn.onclick = function () {
        if (button.action === "restart") {
          restartGame();
        } else if (typeof button.action === "function") {
          button.action();
        } else if (typeof button.action === "string") {
          closeModal();
          handleAreaClick(button.action);
        }
      };
      modalButtons.appendChild(btn);
    }
  });
}

function closeModal() {
  document.getElementById("modal").style.display = "none";
  // æ¬¡ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚Œã°è¡¨ç¤º
  if (window._nextModal) {
    // ç™»éŒ²å†…å®¹ã¯ {title, content, buttons, after} ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    let modal = window._nextModal;
    window._nextModal = null; // ç¹§ï½¯ç¹ï½ªç¹§ï½¢

    if (typeof modal === "function") {
      try {
        modal();
      } catch (e) {}
      window.dispatchEvent(new Event("modal:closed"));
      return;
    }

    if (modal.before) modal.before();
    showModal(modal.title, modal.content, modal.buttons);
    if (modal.after) modal.after();
  }
  window.dispatchEvent(new Event("modal:closed"));
}

// ã‚²ãƒ¼ãƒ ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
function restartGame() {
  gameState = getDefaultGameState();
  closeModal();
  initGame();
  updateInventoryDisplay();
}

let isBGMPlaying = false;
let isBGMInitialized = false;

// åˆå›ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ã ã‘BGMã‚’å†ç”Ÿ
function initBGMOnce() {
  if (!isBGMInitialized) {
    const bgm = document.getElementById("bgm");
    bgm.volume = 0.3;
    bgm.play();
    isBGMPlaying = true;
    isBGMInitialized = true;
    document.getElementById("bgm-toggle").textContent = "îçŸ§ BGM";
  }
}
window.addEventListener("click", initBGMOnce, { once: true });

function toggleBGM() {
  const bgm = document.getElementById("bgm");
  const btn = document.getElementById("bgm-toggle");
  if (!isBGMPlaying) {
    bgm.play();
    isBGMPlaying = true;
    btn.textContent = "îçŸ§ BGM";
  } else {
    bgm.pause();
    isBGMPlaying = false;
    btn.textContent = "îé€™ BGM";
  }
}

function changeBGM(newSrc) {
  const bgm = document.getElementById("bgm");
  // ãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿ã§æ¯”è¼ƒ
  const current = bgm.src.split("/").pop();
  const next = newSrc.split("/").pop();
  if (current === next) return;

  const isPlaying = isBGMPlaying;
  bgm.pause();
  bgm.src = newSrc;
  bgm.load();
  if (isPlaying) {
    bgm.play();
  }
}

function pauseBGM() {
  const bgm = document.getElementById("bgm");
  bgm.src = "";
  bgm.pause();
}

function playSE(id) {
  const se = document.getElementById(id);
  se.currentTime = 0;
  se.play();
}
function stopSE(id) {
  const se = document.getElementById(id);
  se.pause();
}

let loadedImages = {};
function preloadImages() {
  // é©›ï½¨è»ç‹—åˆ¤èœ’ãƒ»
  Object.values(IMAGES.rooms).forEach((val) => {
    if (val && typeof val === "object" && !Array.isArray(val)) {
      ["jp", "en"].forEach((lang) => {
        const list = val[lang];
        if (Array.isArray(list)) {
          list.forEach((src) => {
            if (!loadedImages[src]) {
              const img = new Image();
              img.onload = () => {
                try {
                  renderCanvasRoom();
                } catch (e) {}
              };
              img.src = src;
              loadedImages[src] = img;
            }
          });
        } else if (typeof list === "string") {
          if (!loadedImages[list]) {
            const img = new Image();
            img.onload = () => {
              try {
                renderCanvasRoom();
              } catch (e) {}
            };
            img.src = list;
            loadedImages[list] = img;
          }
        }
      });
      return;
    }
    if (Array.isArray(val)) {
      val.forEach((src) => {
        if (!loadedImages[src]) {
          const img = new Image();
          img.onload = () => {
            try {
              renderCanvasRoom();
            } catch (e) {}
          };
          img.src = src;
          loadedImages[src] = img;
        }
      });
    } else if (typeof val === "string") {
      if (!loadedImages[val]) {
        const img = new Image();
        img.onload = () => {
          try {
            renderCanvasRoom();
          } catch (e) {}
        };
        img.src = val;
        loadedImages[val] = img;
      }
    }
  });

  Object.values(IMAGES.items).forEach((src) => {
    if (!loadedImages[src]) {
      const img = new Image();
      img.onload = () => {
        try {
          renderCanvasRoom();
        } catch (e) {}
      };
      img.src = src;
      loadedImages[src] = img;
    }
  });

  Object.values(IMAGES.modals).forEach((src) => {
    if (!loadedImages[src]) {
      const img = new Image();
      img.onload = () => {
        try {
          renderCanvasRoom();
        } catch (e) {}
      };
      img.src = src;
      loadedImages[src] = img;
    }
  });
}

// save&load
function saveGameToSlot(slotIndex) {
  const toSave = { ...gameState, __version: SAVE_VERSION };

  const payload = {
    data: toSave,
    savedAt: Date.now(),
  };

  localStorage.setItem(SAVE_KEYS[slotIndex], JSON.stringify(payload));
  updateMessage(`ã‚»ãƒ¼ãƒ–${slotIndex + 1}ã«ä¿å­˜ã—ã¾ã—ãŸï¼`);
}

function loadGameFromSlot(slotIndex) {
  const raw = localStorage.getItem(SAVE_KEYS[slotIndex]);
  if (!raw) {
    updateMessage(`ã‚»ãƒ¼ãƒ–${slotIndex + 1}ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“`);
    return;
  }

  let saved;
  try {
    const parsed = JSON.parse(raw);

    if (parsed && parsed.data) {
      saved = parsed.data;
    } else {
      saved = parsed;
    }
  } catch (e) {
    console.error(e);
    updateMessage("ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
    return;
  }

  const def = getDefaultGameState();
  const merged = deepMerge(def, saved);

  if (!Array.isArray(merged.openRooms)) merged.openRooms = def.openRooms.slice();
  if (!merged.currentRoom || !rooms[merged.currentRoom]) merged.currentRoom = def.currentRoom;

  gameState = merged;

  changeRoom(gameState.currentRoom);
  updateInventoryDisplay?.();
  renderNavigation?.();
  updateMessage(`ã‚»ãƒ¼ãƒ–${slotIndex + 1}ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼`);
}

function getSaveSlotLabel(slotIndex) {
  const raw = localStorage.getItem(SAVE_KEYS[slotIndex]);
  if (!raw) {
    return `ã‚»ãƒ¼ãƒ–${slotIndex + 1}ï¼ˆç©ºï¼‰`;
  }
  try {
    const parsed = JSON.parse(raw);
    const savedAt = parsed.savedAt;
    if (!savedAt) {
      return `ã‚»ãƒ¼ãƒ–${slotIndex + 1}ï¼ˆæ—¥æ™‚ä¸æ˜ï¼‰`;
    }
    const d = new Date(savedAt);
    const jp = d.toLocaleString("ja-JP");
    return `ã‚»ãƒ¼ãƒ–${slotIndex + 1}ï¼ˆ${jp}ï¼‰`;
  } catch {
    return `ã‚»ãƒ¼ãƒ–${slotIndex + 1}ï¼ˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ï¼‰`;
  }
}

function openLoadMenu() {
  const buttons = [
    {
      text: getSaveSlotLabel(0),
      action: () => {
        loadGameFromSlot(0);
        closeModal();
      },
    },
    {
      text: getSaveSlotLabel(1),
      action: () => {
        loadGameFromSlot(1);
        closeModal();
      },
    },
    { text: "ã‚„ã‚ã‚‹", action: "close" },
  ];

  showModal("ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’é¸ã‚“ã§ãã ã•ã„", "", buttons, null, {
    columnButtons: true,
  });
}

function saveGame() {
  const buttons = [
    {
      text: getSaveSlotLabel(0) + " ã«ä¸Šæ›¸ãä¿å­˜",
      action: () => {
        saveGameToSlot(0);
        closeModal();
      },
    },
    {
      text: getSaveSlotLabel(1) + " ã«ä¸Šæ›¸ãä¿å­˜",
      action: () => {
        saveGameToSlot(1);
        closeModal();
      },
    },
    { text: "ã‚„ã‚ã‚‹", action: "close" },
  ];

  showModal("ã‚»ãƒ¼ãƒ–å…ˆã‚’é¸ã‚“ã§ãã ã•ã„", "", buttons, null, {
    columnButtons: true,
  });
}

function loadGame() {
  openLoadMenu();
}

function deepMerge(target, source) {
  if (source === undefined || source === null) return target;
  if (Array.isArray(source)) return source.slice();
  if (typeof source === "object") {
    const out = target && typeof target === "object" ? { ...target } : {};
    for (const k of Object.keys(source)) {
      out[k] = deepMerge(target ? target[k] : undefined, source[k]);
    }
    return out;
  }
  return source;
}

function showToast(text, ms = 2600) {
  const el = document.getElementById("toast");
  if (!el) return;
  el.textContent = text;
  el.style.opacity = "1";
  el.style.transform = "translateX(-50%) translateY(0)";
  setTimeout(() => {
    el.style.opacity = "0";
    el.style.transform = "translateX(-50%) translateY(-8px)";
  }, ms);
}

window.addEventListener("resize", () => renderNavigation());

window.addEventListener("keydown", (e) => {
  if (e.key === "F2") {
    DEV_MODE = !DEV_MODE;
    renderCanvasRoom();
  }
});

preloadImages();
initGame();
